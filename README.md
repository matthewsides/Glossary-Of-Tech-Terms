# Glossary Of Tech Terms üìñ

This is a alphabetic,multi-sectioned list pertaining to tech dialects, subjects or text with explanations;a brief Dictionary.


‚ñ™ [1] Scrum        

‚ñ™ [2] Programming Paradigms    

‚ñ™ [3] Algorithms

‚ñ™ [4] IDE

‚ñ™ [5] Compiler

‚ñ™ [6] Interpreter

‚ñ™ [7] Debugging

‚ñ™ [8] Coding Standards

‚ñ™[9] Technical Solutions Comparision

‚ñ™[10] Threats an Organisation would face

## [1] Scrum 

Scrum is a framework for project management that emphasizes teamwork, accountability and iterative progress toward a well-defined goal. 

### 10 Key SCRUM Terms

#### 1. Sprint

Sprint is an iteration of work in which an increment of product functionality is implemented. This usually lasts 30 days, though may vary depending on the situation and amount of time allocated or avaliable.

#### 2. Sprint Backlog

Sprint Backlog essentially defines the work for a sprint represented by the tasks and must be met or completed to realize the sprint goals. 

#### 3. SCRUM Roles

There are three essential roles in any Scrum project;Product Owner,Scrum Master, Team.

####  4. Impediments

An Impediment is anything preventing a team member from working productivly or efficiently.Each team member has an opportunity to announce impediments during the daily Scrum meeting. The ScrumMaster is charged with ensuring impediments get resolved. 

#### 5. Product Backlog

The product backlog is the requirements for a system, expressed as a prioritized list of product backlog Items (tasks set on list set by priority level). 

#### 6. Product Backlog Item

In Scrum, a product backlog item is a unit of work small enough to be completed by a team in one Sprint iteration.

#### 7. Team

A team (or "Scrum team") is optimally comprised of a group of people working together to acheive a certain goal.

#### 8. Team Member

In Scrum parlance (terminology) , a team member is defined as anyone working on sprint tasks toward the sprint goal.

#### 9. Velocity

In Scrum, velocity is how much product backlog effort a team can handle in one sprint. This can be estimated by viewing previous sprints.

#### 10. Daily Scrum Meeting

A fifteen-minute daily meeting supervised by the Scrum Master for each team member to answer three questions:

"What have I done since the last Scrum meeting? (i.e. yesterday)"

"What will I do before the next Scrum meeting? (i.e. today)"

"What prevents me from performing my work as efficiently as possible?"

## [2] Programming Paradigms    

A programming paradigm is a style, or ‚Äúway,‚Äù of programming.

### Procedural

Procedural programming is a paradigm based on the concept of using procedures. Procedure (sometimes also called subprogram, routine or method) is a sequence of commands to be executed.

#### Characteristics of Procedural 

‚ñ™ It focuses on process rather than data.

‚ñ™ It takes a problem as a sequence of things to be done such as reading, calculating and printing. Hence, a number of functions are written to solve a problem.

‚ñ™ A program is divided into a number of functions and each function has clearly defined purpose.
Most of the functions share global data.

‚ñ™ Data moves openly around the system from function to function.

### Event Driven

Event-driven programming is a programming paradigm in which the flow of program execution is determined by events - for instance a user action such as a mouse click, key press, or a message from the operating system or another program.

#### Characteristics of Event Driven

‚ñ™ Service Orientated meaning that it provides services that are available on a network, ensruing that code does not have to be repeated or rewritten everytime and can be referenced.  

‚ñ™ It can be time driven meaning that specific code may run at a certain time (pre-set trigger).

‚ñ™ It uses event handlers, which is a type of function or method that runs a specific action when a specific event is triggered. 

‚ñ™ Event Driven programming is typically visual, ensuring its simplicity and ease of development. 

‚ñ™ It is based around events (hence the name).

### Object Orientated

Object-oriented programming (OOP) is a programming paradigm organized around objects rather than "actions" and data rather than logic.

#### Characteristics of Object Orientated

‚ñ™ It emphasis in own data rather than procedure.

‚ñ™ It implements programs using the objects.

‚ñ™ Data and the functions are wrapped into a single unit called class so that data is hidden and therefore safe from accidental alternation.

‚ñ™ Objects communicate with each other through functions.

‚ñ™ New data and functions may be added whenever necessary.

### Relationship Between the Programming Paradigms

Programming paradigms are essentially a collective of concepts (concepts make up the paradigms), a programming paradigm may herald a different name but have the same set of concepts,a concept may be added to go from one paradigm to the next (programming paradigms build upon each other and branch out like a taxonomy, working inconjunction), this ties into the relationship or how the programming paradigms are linked as often two paradigms that seem quite different (for example, functional  programming and object-oriented programming) differ by just one concept.  

Though many of these paradigms are useless in practice, such as the empty paradigm (no concepts) or paradigms with only one concept.

The taxonomy of programming paradigms may be seen through the diagram displayed below:


![Alt text](https://github.com/matthewsides/Glossary-Of-Tech-Terms/blob/master/programming_paradigms.jpg?raw=true "Optional Title")

Further building upon the idea that each paradigm utimately is made up of numerous conceptual methodologys, linking into the relationship between the three paradigms listed and covered in the above sections. The three paradigms (object,event and procedural) relationship may be seen to be tightly linked to the fact that all three of the paradigms may perform the same functions and produce the same outcome, the only difference is the way in which the proccess is performed (essentially the outcome for all the paradigms is the same, but how that outcome is achieved is ultimately different).

## [3] Algorithms

An algorithm is a set of instructions  (rules to be followed), used for calculations or other problem-solving operations.

### Proccess of building an Application

#### I.   Requirement gathering 

The act of requirement gathering (or ‚Äúrequirements elicitation‚Äù) essentially refers specifically to the practice of defining software requirements, said requirements are usually retrieved from a client.

Furthermore during this phase the prospective client usually analyses market requirements and features that are in demand, delving into the supply and demand aspect of the market seeing whether there is a real need for the software that is being developed in the current market. This essentially molds the requirements.

A comprehensive understanding of the customers‚Äô needs and writing down features of the proposed software product are the keys to success in this phase. 


#### II.  Writing functional specifications 
Following said client gathering, a review should ensue to determine whether said pre-defined or set requirements given by the client are plausible, subsequently then determining as to how to achieve said specifications (Functional specifications are based upon the product requirements documentation put forward), drawing upon a functional specification document, showing the behaviour or functionality of a software product on an abstract level.

The prominence of the usage of writing functional specifications relate to the creation of a design document, manuals for end-users, functional and architecture documents, being a means to communicate among groups disconnected by their software development landscape. Although during the product development phase amendments to functional specifications may be necessary, keeping in view new marketing requirements. 



#### III. Creating architecture and design documents 

The architecture document in effect is formed once all the requirements have been collected and arranged. The document defines different components of the product and how they interact with each other. Whilst the design document details a written description of a software product, written by  a software designe in order to give a software development team overall guidance to the architecture of the software project.


#### IV.  Implementation and coding

The Implementation and coding phase is initiated when software developers take the design documents and development tools (editors, compilers, debuggers etc.) and start writing software. 

This is an erroneous process and usually the longest phase in the product life cycle. Each developer has to write their own code to a standard, whilst collaborating with other developers to ensure that different components can interoperate with each other.

Subsequently this problematic issue may-be generally bypassed through using or outlining coding standards beforehand, ensuring that the written procedures are followed or abided by, thus enabling the code to be similar structurally and aesthetically. 

Furthermore, elaborating the reason for coding standards, during the project or product life cycle multiple people may modify files, therefore if people are not following the pre-set rules, this may easily break the whole compilation and building process. 

For instance, duplicate definitions of the same variables may cause problems, while similarly, if included files are not written properly, you can easily cause the creation of loops.

#### V.	  Testing and quality assurance 

Subsequently once the implementation and coding stage is completed, the next phase in software development is to test said code to see whether it is functional and works to an exceptional standard meeting and assuring the quality. 

This may be initiated through managing the product life cycle and verifying that the software meets the defined quality standards or customer agreements (quality assurance), thereafter with regards to the testing aspect may be instigated during the production phase, concerned with finding ways of breaking software, coding in segments or pushing out versions of said application software are integral to ensure a more accurate test. 

In addition, throughout testing the ideology behind it is to get a group of testers to observe what the software does and to report on the level of quality as well as any serious issues they encounter (under the assumption that the system is flawed and has copious amounts of bugs).



#### VI.	Software release 

Before the subsequent marketing and selling of a software product it needs to be officially released. This essentially pertaining to the creation of a state of the software in a repository (a copy), ensuring that it has been tested for functionality, etc. 

A version number is assigned to the released software.After releasing the software, development may continue but will not impact or make any subsequent changes to the released software. The development is usually carried on in a new branch and it may contain new features of the product. The released software is updated only if a bug fixed version is released. 



#### VII.	Documentation 

Reliable documentation is crucial throughout software development (life cycle). The presence of documentation helps keep track of all aspects of an application and improves on the quality of a software product. Furthermore, mainly focusing on development, maintenance and knowledge transfer to other developers. 


#### VIII.Support and new features

This usually heralds after the development of software, though is still integral to the cycle as users of said developed software may need support after release. In addition, new features may be a factor or prerequisite with updates coming out to compete with competitors‚Äô products that may have other features.  Moreover, better support usually leads to better branding and devotion among user‚Äôs, creating or leading to the generation of a referral business.

## [4] IDE

An integrated development environment (IDE) is a software suite that consolidates the basic tools developers need to write and test software. 

### Analysis of Common Features of An IDE

The common features of an Intergrated Development System usually consist of a colour scheme used to indicate or differentiate between comments, conditional statements, string, int,  etc. from other code. 

Furthermore IDE's feature a text editor area that allows developers to write, edit and save a document of code. In addition Auto-completion, syntax checks and bracket matching are also intergrated features of IDE's which suggests an autocompletion for a function, any arguments and variables (auto completion) , Marks out blocks of code to improve the structure  (Bracket Matching) and recognises incorrect use of syntax and highlights any errors (syntax checks).

Moreover another common feature of an IDE would be the libaries, used in IDE's to import pre-set code, already developed into blocks for re-use to make coding easier and also shorten the amount of code in the text-editor.

### The use of an IDE for development of applications contrasted with not using an IDE.

The fundemental differences of using an IDE for the development of applications contrasted with not using an IDE stem from Adrons ideology of moving tools from local onto a network outsourcing it, making it easier to access and sharing code which in an IDE is compiled into libaries to further make things easier. Whilst not using an IDE there are no pre-set or specific libaries to call upon, meaning that it must be done manually making it a more strenous and increasing the longevity of the task (program), though certain os functions may be called upon, using said functions may affect the compatability of the application with other OS or platforms.

Furthermore depending on the language that the program will run on, the choice of IDE may be quite limited, and the choices available might be fairly complicated applications.For instance when using one of Microsofts .NET languages (C#, Visual Basic, or ASP.NET),  Visual Studio is commonly referred (mentioned), though it isnt the  only option, but is the most common. ( Through not using an IDE contrasting or incomparision to using an IDE, not using an IDE is more flexible in that retrospect.(note:exclude/remove sentence in brackets))

Moreover  IDE's offer a broad and wide range of features and tools  that can help improve the rate in which the project is being done and the debugging as IDE's typically highlight as to what it cannot execute or cannot understand pointing to a certain line where it encountered the error also stating whether the error was a syntax,logical or user, thus making it easier to distinguish and fix incomparision to not using an IDE (for instance vi or emacs, though could be argued that vi and emacs have features similiar to IDE's, a libary), which doesnt point out any defects or problems and thus must be manually checked through either using a written debugging code or going through each line. 

Inaddition IDE's commonly apply a colour scheme thus making it easier to distinguish a controlled statement, loop, error, string or intergers as everything is colour cordinated and thus easier to reference to the colour, providing visual aid.

Thereafter IDE's can be regarded as more time efficent and user friendly in particular to those that may not be as particularly experienced, whilst not using an IDE for coding or building an application is more likely to cater to more experienced programmers who type their code in to an exceptional standard first time.Broadly stating programmers who work in scripting languages, or languages that evolved from scripting languages, are more likely to regard an IDE as optional.


## [5] Complier

'High-level language is converted into binary language in various phases.'
A compiler is a program that converts high-level language to assembly language. Which is then converted into Machine level language from assembly language. 

### How a Compiler functions:

‚ñ™ User writes a program in a language (high-level language).

‚ñ™ The compiler, compiles the program and translates it to assembly program (low-level language).

‚ñ™ An assembler then translates the assembly program into machine code (object).

‚ñ™ A linker tool is used to link all the parts of the program together for execution (executable machine code).

‚ñ™  A loader loads all of them into memory and then the program is executed.

### Steps from Writing code to Execution

‚ñ™ A flowchart or psuedo code is usually pieced together, with the flowchart or psuedo code being a representation of how the program should function (similiar to a prototype, though not actually coded).

‚ñ™ The functions, operators, statements, etc. in Psuedo code are usually based on ones own knowledge, though in creating a flow chart specific shapes represent specific things for instance the circle represents the beginning and end of a program, whilst the square represnts a proccess, the rhombus relates to taking input and giving output (so for c++ a representation of cin and cout) and the diamond is a visual representation for (loops like for and while) conditional statements like if, else etc.

‚ñ™ Once an planned algorithm is created the next step would be to translate said psuedo code or flowchart to High-level-Language (code), which as covered briefly in the above step each shape in a flowchart relates or should relate to the functions, conditional statements, etc. found in the high-level language. Whilst if psuedo code is being used it should be based on ones own representation of all the functions, statments etc. in the language.

‚ñ™ After the algortihm has successfully been converted, the IDE's compiler should compile the program and translate it to assembly program (low-level language) (essentially the compiler takes care of the next steps).

‚ñ™ An assembler should then translate the assembly program into machine code (object).

‚ñ™ A linker tool is used to link all the parts of the program together for execution (executable machine code).

‚ñ™  A loader loads all of them into memory and then the program is executed.

## [6] Interpreter

An Interpreter is a program that executes instructions written in a high-level language. There are two ways to run programs written in a high-level language. The most common is to compile the program (covered above); the other method is to pass the program through an interpreter.

An interpreter translates high-level instructions into an intermediate form, which it then executes.

## [7] Debugging

Debugging is the process of working through a program in a systematic way, finding and resolving defects or problems within the program that prevent correct operation of computer software or a system. 

### Debugging Tools and proccess

The proccess of debugging is, as aliterated in the above section, the proccess of working through a program systematically, searching for faults within a program that prevent correct operation, thereafter resolving said defects once found.

Furthermore regarding the debugging proccess IDE's(Intergrated Development Enviroment) generally have intergrated tools that support and heave a portion of the workload during the debugging proccess. For instance python includes a logging module that allows a user to print values and analyse errors,this is more efficent and benifical, rather than being required to print each statement to see what value is being held in a variable having to move it later, other IDE's also include modules similiar or built for other reasons specifically with debugging in mind.

Moreover with regards to debugging the majority of IDE's also incorparate syntax checks that automatically recognises incorrect use of syntax and highlights any errors, thus alleviating the work load expected by the user. 

Inaddition to having a runtime enviroment, which essentially allows a user to run a program one line at a time, useful for testing to see whether each line of code is working before formulating a complete program.

What is more IDE's also resort to the use of debuggers, fudementally a program within the IDE that is used to detect errors. If the debugger detects errors, it may suggest what the type of error is and what line it is on. This is essentially most suitable and critical as if an IDE is to exclude the use of a debugger then it is likely to lead to an inefficent practice and poor software build, though there are other software programs that specialise in this exact proccess so though detrimental, it is still possible if exclude in the IDE and the software is compatible with the (chosen) language of choice.

Whilst another tool (though not particuarlly linked to debugging but the overall software quality) that is generally found in an IDE consists of build automation, which in principle automatically initiates proccess that would have ussually been done manually, useful when an extensive amount of code is present, improving the software quality , minimising bad software builds and saving resources. 

### How the debugging process can be used to help develop more secure, robust applications.

The debugging proccess can be used to help develop more secure, robust applications, though to first undertstand how, it is required to first know what the robustness of a system is, which in this instance robustness relates to the ability of a computer system to cope with errors during execution and cope with erroneous input. 

This links into the proccess of debugging code as through debugging, erroneous input implications may be encountered during run-mode and thereafter fixed through writing a failsafe for when such input is given or action initiated, essentially accounting for the defect and building upon it thus making the application more robust as the problem is accounted for (hindsight). 

Furthermore using the debugging process errors may be found during build or run mode and sorted (code tweaked) thus ensuring that said errors are not encountered again, in particular finding errors detrimental to whether the software will even run or freeze upon initiating a certain function etc.  This is a particularlly useful metholodgy or proccess used by most coders working for organisations so as to ensure there are no problems upon release of the software or program they are making to the client or public (since an insecure program will ganer unease and impact branding). 

Inaddition the errors may be documented and thus in future projects if any similiar problems occur the document may be referenced. The debugging proccess is essentially crucial to helping develop and build a more secure, robust application, as errors (logical,syntax and user errors) are located and built upon with fail safes put in place to tackle said errors (build upon the mistakes, learning in the proccess and gaining experience as to the best way to structure and code a program, thus improving the robustness).

## [8] Coding Standards

Coding standards define a programming style. A coding standard does not usually conform to norms of defining what is wrong or right more in a abstract sense. It is essentially a set of rules and guidelines for the formatting of source code.

### Why a coding standard is necessary in a team as well as for an individual.

Coding standards are necessary in a team as well as for an individual because the use of coding standings basically ensure that code is more "maintainable" and easier to read and understand when another developer views the code. 

The fundemental problem of not using a coding standard for a language stems from when a particular style is adapted and becomes second nature which will be used in everything that is created, however the problems are more noticable when coding for bigger projects that lead to the introduction of additional people to help create the large application as conflicts in the way the code is written will likely or most definitely appear as what is understandable to one developer may not be understandable to another (conform to their style). 

This is commonly seen in the gaming industry where franchises such as call of duty tend to re-create from scratch rather than recycling old code since it is likely that the standards they have used will not be friendly to them. 

In regards to the nessecity for an individual, as briefly mentioned above it can improve the structure, make the code more maintainable and easier to read and understand not just for the individual but also anyone else other than the developer reading through the code.

Though formulating coding standards or ensuring that they are followed  inparticular for large groups of developers working on a project togetherthe solution would be a coding standards document as it  tells developers how they must write their code. Instead of each developer coding in their own preferred style, they will write all code to the standards outlined in the document. This makes sure that a large project is coded in a consistent style ‚Äî parts are not written differently by different programmers. Not only does this solution make the code easier to understand, it also ensures that any developer who looks at the code will know what to expect throughout the entire application.

## [9] Technical Solutions Comparision 

Technical solutions may essentially be compared through effective analysis.  Effective analysis in principle relates to the measurement of a system (program), during which is relative or in another term considered in relation or in proportion to something else. Effective analysis usually starts through comparing the problem or opportunity system context. 

The analysis will usually explain basic system derivatives, covering how well the system functions , using performance criteria associated with both the system‚Äôs primary and enabling functions. Whilst also checkking whether the system suits the requirements set  or expected  by user's, derived from the systems purpose. 

Subsequently with regards to a product system there are a set of generic non-functional qualities that are associated with different types of solution patterns or technology, e.g., safety, security, reliability, maintainability, usability, etc. These criteria are often explicitly stated as parts of the domain knowledge of related technical disciplines in technology domains.

In addition to assessments of the absolute effectiveness of a given solution system, the effectiveness anaylisis in addition to effectiveness, must be combined with the limitations of cost and timescales included. In general, the role of system analysis is to identify the proposed solutions which can provide some effectiveness within the cost and time allocated to any given iteration of the systems approach (used to identify the best software to use to meet requirements and fix a problem). If none of the solutions can deliver an effectiveness level that justifies the proposed investment or meets the standard expected, then it is necessary to return to the original framing of the problem. If at least one solution is assessed as sufficiently effective, then a choice between solutions can be proposed.


## [10] Threats an Organisation would face

The Threats that an organisation may face can stem from internal or external sources, human error or an act of malicious intentions and software that either exploits the organisations systems functions installed on to the devices stored in there facilitys or human psyche, thus the continuation of such threats cause a plethora of problems for organisations, in particular a research carried out by IBM (In the 2016 Cyber Security Intelligence Index) found that in 2016 60% of all breaches (attacks) were caused internally, hence the reason for procedures and policys brought about by organisations.

Further delving into the external aspect, this is usually intruders outside trying to gain access to files from the organisation that are not already permitted to be viewed from an outside company perspective. The external threats are generally dynamic and uncertain, thus an organisation may not alter the course of events to happen in the event of a hack, though precautions may be taken to ensure there is no bypass, ensuring each system has firewall and anti virus protection. Whilst on the Human side or aspect implement procedures and rules and regulations that need to be followed either in the event or autonomously throughout their time working for the organisation to ensure no information is leaked. 

In continuation, elaborating on the idea of internal threats, the term internal links to the inside of an organisation and the threats that an organistion could face linking to internal usually stem from an employee within an organisation that becomes disaffected and trys to hack the organisation network.Thereafter leading to files being lost or retrieved and used to the companys disadvantage and usually the employees advantage. 

Moroever with regards to internal and human threats, there have been numerous cases where an organisations files that have been deemed a priority and top secret have been released onto public domain or sent to people outside the company, though ocassionally done purposely, has been done accidently which for an organisation is a threat within itself. 

More Threats an Organisation May Face-

Trojans

Denial of service (attack)

Worms attack

Phishing

Hacking

Identity theft 

Piggy backing

Network Monitoring 

Data Theft 

Technical failures

Employees

Malware

Viruses

