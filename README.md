# Glossary Of Tech Terms üìñ

This is a alphabetic,multi-sectioned list pertaining to tech dialects, subjects or text with explanations;a brief Dictionary.


‚ñ™ [1] Scrum        

‚ñ™ [2] Programming Paradigms    

‚ñ™ [3] Algorithms

‚ñ™ [4] IDE

‚ñ™ [5] Compiler

‚ñ™ [6] Interpreter

‚ñ™ [7] Debugging

## [1] Scrum 

Scrum is a framework for project management that emphasizes teamwork, accountability and iterative progress toward a well-defined goal. 

### 10 Key SCRUM Terms

#### 1. Sprint

Sprint is an iteration of work in which an increment of product functionality is implemented. This usually lasts 30 days, though may vary depending on the situation and amount of time allocated or avaliable.

#### 2. Sprint Backlog

Sprint Backlog essentially defines the work for a sprint represented by the tasks and must be met or completed to realize the sprint goals. 

#### 3. SCRUM Roles

There are three essential roles in any Scrum project;Product Owner,Scrum Master, Team.

####  4. Impediments

An Impediment is anything preventing a team member from working productivly or efficiently.Each team member has an opportunity to announce impediments during the daily Scrum meeting. The ScrumMaster is charged with ensuring impediments get resolved. 

#### 5. Product Backlog

The product backlog is the requirements for a system, expressed as a prioritized list of product backlog Items (tasks set on list set by priority level). 

#### 6. Product Backlog Item

In Scrum, a product backlog item is a unit of work small enough to be completed by a team in one Sprint iteration.

#### 7. Team

A team (or "Scrum team") is optimally comprised of a group of people working together to acheive a certain goal.

#### 8. Team Member

In Scrum parlance (terminology) , a team member is defined as anyone working on sprint tasks toward the sprint goal.

#### 9. Velocity

In Scrum, velocity is how much product backlog effort a team can handle in one sprint. This can be estimated by viewing previous sprints.

#### 10. Daily Scrum Meeting

A fifteen-minute daily meeting supervised by the Scrum Master for each team member to answer three questions:

"What have I done since the last Scrum meeting? (i.e. yesterday)"

"What will I do before the next Scrum meeting? (i.e. today)"

"What prevents me from performing my work as efficiently as possible?"

## [2] Programming Paradigms    

A programming paradigm is a style, or ‚Äúway,‚Äù of programming.

### Procedural

Procedural programming is a paradigm based on the concept of using procedures. Procedure (sometimes also called subprogram, routine or method) is a sequence of commands to be executed.

#### Characteristics of Procedural 

‚ñ™ It focuses on process rather than data.

‚ñ™ It takes a problem as a sequence of things to be done such as reading, calculating and printing. Hence, a number of functions are written to solve a problem.

‚ñ™ A program is divided into a number of functions and each function has clearly defined purpose.
Most of the functions share global data.

‚ñ™ Data moves openly around the system from function to function.

### Event Driven

Event-driven programming is a programming paradigm in which the flow of program execution is determined by events - for instance a user action such as a mouse click, key press, or a message from the operating system or another program.

#### Characteristics of Event Driven

‚ñ™ Service Orientated meaning that it provides services that are available on a network, ensruing that code does not have to be repeated or rewritten everytime and can be referenced.  

‚ñ™ It can be time driven meaning that specific code may run at a certain time (pre-set trigger).

‚ñ™ It uses event handlers, which is a type of function or method that runs a specific action when a specific event is triggered. 

‚ñ™ Event Driven programming is typically visual, ensuring its simplicity and ease of development. 

‚ñ™ It is based around events (hence the name).

### Object Orientated

Object-oriented programming (OOP) is a programming paradigm organized around objects rather than "actions" and data rather than logic.

#### Characteristics of Object Orientated

‚ñ™ It emphasis in own data rather than procedure.

‚ñ™ It is based on the principles of inheritance, polymorphism, encapsulation and data abstraction.

‚ñ™ It implements programs using the objects.

‚ñ™ Data and the functions are wrapped into a single unit called class so that data is hidden and therefore safe from accidental alternation.

‚ñ™ Objects communicate with each other through functions.

‚ñ™ New data and functions may be added whenever necessary.

### Relationship Between the Programming Paradigms

Excluding the obvious fact that Event-Driven, Object-Orientated and Procedural programming are Programming Paradigms, the relationship between the paradigms is that they may all be used inconjunction with eachother, since event driven programming supports all languages, whilst object orientated programming is essentailly a fix for the limitations of procedural programmingand therefore functions similiarly, though the implementation proccess  may be different.

## [3] Algorithms

An algorithm is a set of instruction, used for calculations or other problem-solving operations.

### Implementation proccess of Algorithm

#### 1. Establish the Rules of a Problem

A problem can usually be interpreted in multiple ways and the response is what is integral in this instance, though complications may be encountered, the proccess of figuring out what went wrong is the ideology that programming is based around (the point of programming).

#### 2. Explore the problem space

The above heading or idea of 'explore the problem space' essentially refering to not constraining (rigorous constraints)  yourself whilst thinking and solving the problem,as this usually leads to long lists of steps that may not necessarily coincide with the steps of an algorithm. Inconjunction with the idea of exploring the problem space rather then constraning oneself, it is acceptable to note loose ideas of a plan down, though it must be acknowledged that the problem is still in the thought proccess stage ( your still thinking of the problem) and that the list of ideas may not be the most ambiable (suitable) to solving the problem.  

#### 3. Specify a plan and elaborate into steps

Essentially put the overall plan into simple steps (flow chart or sudo code is applicable) that may be read and understood after a brief flick, ensure that  pronouns aren't used and be very specific. 

Optionally verify each step in the process for some simple input. Though ensure that there is no confusion as to what should happen and is happening, preferably pretending that you do not know the function or purpose of the pseudocode or what its doing when reading through it (Note: could ask external help for this). 

#### 4. Translate each step into code 

This step is deterministic, since the code language used is relative and as long as the steps translated into a High-Level-programming language are the same, the outcome should be similiar after the code is compiled into Machine-code or Lower-level.

## [4] IDE

An integrated development environment (IDE) is a software suite that consolidates the basic tools developers need to write and test software. 

### Analysis of Common Features of An IDE

The common features of an Intergrated Development System usually consist of a colour scheme used to indicate or differentiate between comments, conditional statements, string, int,  etc. from other code. 

Furthermore IDE's feature a text editor area that allows developers to write, edit and save a document of code. In addition Auto-completion, syntax checks and bracket matching are also intergrated features of IDE's which suggests an autocompletion for a function, any arguments and variables (auto completion) , Marks out blocks of code to improve the structure  (Bracket Matching) and recognises incorrect use of syntax and highlights any errors (syntax checks).

Moreover another common feature of an IDE would be the libaries, used in IDE's to import pre-set code, already developed into blocks for re-use to make coding easier and also shorten the amount of code in the text-editor.

### The use of an IDE for development of applications contrasted with not using an IDE.

The fundemental differences of using an IDE for the development of applications contrasted with not using an IDE stem from Adrons ideology of moving tools from local onto a network outsourcing it, making it easier to access and sharing code which in an IDE is compiled into libaries to further make things easier. Whilst not using an IDE there are no pre-set or specific libaries to call upon, meaning that it must be done manually making it a more strenous and increasing the longevity of the task (program), though certain os functions may be called upon, using said functions may affect the compatability of the application with other OS or platforms.

Furthermore depending on the language that the program will run on, the choice of IDE may be quite limited, and the choices available might be fairly complicated applications.  For instance when using one of Microsofts .NET languages (C#, Visual Basic, or ASP.NET),  Visual Studio is coomonly referred (mentioned), though it isnt the  only option, but is the most common.

## [5] Complier

'High-level language is converted into binary language in various phases.'
A compiler is a program that converts high-level language to assembly language. Which is then converted into Machine level language from assembly language. 

### How a Compiler functions:

‚ñ™ User writes a program in a language (high-level language).

‚ñ™ The compiler, compiles the program and translates it to assembly program (low-level language).

‚ñ™ An assembler then translates the assembly program into machine code (object).

‚ñ™ A linker tool is used to link all the parts of the program together for execution (executable machine code).

‚ñ™  A loader loads all of them into memory and then the program is executed.

### Steps from Writing code to Execution

‚ñ™ A flowchart or psuedo code is usually pieced together, with the flowchart or psuedo code being a representation of how the program should function (similiar to a prototype, though not actually coded).

‚ñ™ The functions, operators, statements, etc. in Psuedo code are usually based on ones own knowledge, though in creating a flow chart specific shapes represent specific things for instance the circle represents the beginning and end of a program, whilst the square represnts a proccess, the rhombus relates to taking input and giving output (so for c++ a representation of cin and cout) and the diamond is a visual representation for (loops like for and while) conditional statements like if, else etc.

‚ñ™ Once an planned algorithm is created the next step would be to translate said psuedo code or flowchart to High-level-Language (code), which as covered briefly in the above step each shape in a flowchart relates or should relate to the functions, conditional statements, etc. found in the high-level language. Whilst if psuedo code is being used it should be based on ones own representation of all the functions, statments etc. in the language.

‚ñ™ After the algortihm has successfully been converted, the IDE's compiler should compile the program and translate it to assembly program (low-level language) (essentially the compiler takes care of the next steps).

‚ñ™ An assembler should then translate the assembly program into machine code (object).

‚ñ™ A linker tool is used to link all the parts of the program together for execution (executable machine code).

‚ñ™  A loader loads all of them into memory and then the program is executed.

## [6] Interpreter

An Interpreter is a program that executes instructions written in a high-level language. There are two ways to run programs written in a high-level language. The most common is to compile the program (covered above); the other method is to pass the program through an interpreter.

An interpreter translates high-level instructions into an intermediate form, which it then executes.

## [7] Debugging

Debugging is the process of finding and resolving defects or problems within the program that prevent correct operation of computer software or a system.

### How the debugging process can be used to help develop more secure, robust applications.

The debugging proccess can be used to help develop more secure, robust applications, though to first undertstand how, it is required to first know what the robustness of a system is, which in this instance robustness relates to the ability of a computer system to cope with errors during execution and cope with erroneous input. 

This links into the proccess of debugging code as through debugging, erroneous input implications may be encountered during run-mode and thereafter fixed through writing a failsafe for when such input is given or action initiated, essentially accounting for the defect and building upon it thus making the application more robust as the problem is accounted for (hindsight). 

Furthermore using the debugging process errors may be found during build or run mode and sorted (code tweaked) thus ensuring that said errors are not encountered again, in particular finding errors detrimental to whether the software will even run or freeze upon initiating a certain function etc.  This is a particularlly useful metholodgy or proccess used by most coders working for organisations so as to ensure there are no problems upon release of the software or program they are making to the client or public (since an insecure program will ganer unease and impact branding). 

Inaddition the errors may be documented and thus in future projects if any similiar problems occur the document may be referenced. The debugging proccess is essentially crucial to helping develop and build a more secure, robust application, as errors (logical,syntax and user errors) are located and built upon with fail safes put in place to tackle said errors (build upon the mistakes, learning in the proccess and gaining experience as to the best way to structure and code a program, thus improving the robustness).

